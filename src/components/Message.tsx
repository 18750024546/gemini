import React, { useState, useEffect, useRef } from 'react';
import ReactMarkdown from 'react-markdown';
import { Prism as SyntaxHighlighter } from 'react-syntax-highlighter';
import { atomDark } from 'react-syntax-highlighter/dist/esm/styles/prism';
import remarkGfm from 'remark-gfm';
import remarkMath from 'remark-math';
import rehypeKatex from 'rehype-katex';
import 'katex/dist/katex.min.css';

interface MessageProps {
  role: 'user' | 'model';
  text: string;
  isLast?: boolean;
  isStreaming?: boolean;
  onRegenerate?: () => void;
}

const Message: React.FC<MessageProps> = ({ role, text = '', isLast, isStreaming, onRegenerate }) => {
  const [isThinkingOpen, setIsThinkingOpen] = useState(false);
  const hasAutoCollapsedRef = useRef(false);
  const prevStreamingRef = useRef(isStreaming);
  
  // Robust parsing for streaming content
  const safeText = typeof text === 'string' ? text : '';

  let thinkingContent: string | null = null;
  let mainContent = safeText;
  let referencesContent: string | null = null;

  // 1. Extract Thinking Process
  const thinkingStartTag = '<thinking>';
  const thinkingEndTag = '</thinking>';
  const thinkingStartIndex = safeText.indexOf(thinkingStartTag);
  const thinkingEndIndex = safeText.indexOf(thinkingEndTag);

  if (thinkingStartIndex !== -1) {
    if (thinkingEndIndex !== -1 && thinkingEndIndex > thinkingStartIndex) {
      // Complete thinking block
      thinkingContent = safeText.substring(thinkingStartIndex + thinkingStartTag.length, thinkingEndIndex).trim();
      // Remove thinking block from main content
      if (thinkingStartIndex === 0) {
          mainContent = safeText.substring(thinkingEndIndex + thinkingEndTag.length).trim();
      } else {
          mainContent = safeText.substring(0, thinkingStartIndex) + safeText.substring(thinkingEndIndex + thinkingEndTag.length);
      }
    } else {
      // Incomplete thinking block (streaming)
      thinkingContent = safeText.substring(thinkingStartIndex + thinkingStartTag.length).trim();
      mainContent = safeText.substring(0, thinkingStartIndex).trim(); 
    }
  } else if (thinkingEndIndex !== -1) {
    // Missing opening tag but has closing tag (Robustness fix)
    thinkingContent = safeText.substring(0, thinkingEndIndex).trim();
    mainContent = safeText.substring(thinkingEndIndex + thinkingEndTag.length).trim();
  }

  // 2. Extract References (from the remaining mainContent)
  // We want to capture BOTH Manual References (generated by model) AND Auto References (appended by stream).
  // They usually appear at the end. We look for the FIRST occurrence of a reference header
  // to collapse everything following it into the "Reference Sources" accordion.
  
  const allRefHeaders = [
      '**Search Queries Used:**',
      '**Search Queries Used**',
      '**ÊêúÁ¥¢Êü•ËØ¢:**',
      '**ÊêúÁ¥¢Êü•ËØ¢**',
      'Search Queries Used:',
      'Search Queries Used',
      'Reference Sources',
      'References',
      'ÂèÇËÄÉÊñáÁåÆ',
      '**Reference Sources**',
      '**References**',
      '**ÂèÇËÄÉÊñáÁåÆ**',
      '## Reference Sources',
      '## References',
      '## ÂèÇËÄÉÊñáÁåÆ',
      '### Reference Sources',
      '### References',
      '### ÂèÇËÄÉÊñáÁåÆ'
  ];

  let bestRefIndex = -1;
  let bestRefHeaderLength = 0;
  const lowerMain = mainContent.toLowerCase();

  for (const header of allRefHeaders) {
      const lowerHeader = header.toLowerCase();
      // We look for the header preceded by a newline or at the start of the string
      // to avoid false positives in the middle of sentences.
      const index = lowerMain.indexOf(lowerHeader);
      
      if (index !== -1) {
          // Check if it's at the start or preceded by newline
          const isStart = index === 0;
          const isPrecededByNewline = index > 0 && mainContent[index - 1] === '\n';
          // Also check for double newline or markdown markers
          const isPrecededByMarkdown = index > 2 && mainContent.substring(index - 3, index).includes('\n');

          if (isStart || isPrecededByNewline || isPrecededByMarkdown) {
               if (bestRefIndex === -1 || index < bestRefIndex) {
                   bestRefIndex = index;
                   bestRefHeaderLength = header.length;
               }
          }
      }
  }

  if (bestRefIndex !== -1) {
     if (bestRefIndex < mainContent.length) {
         // Include the header in the references content so it renders nicely inside the markdown
         // actually, we might want to strip the header to avoid duplication with the summary
         // But the summary says "Reference Sources".
         // Let's keep the content but maybe strip the leading header if it's just "References"
         // to avoid "Reference Sources \n ## References".
         
         // For now, just capture everything.
         referencesContent = mainContent.substring(bestRefIndex).trim();
         
         // Remove from main content
         mainContent = mainContent.substring(0, bestRefIndex).trim();
         
         // Clean up trailing separators in main content
         mainContent = mainContent.replace(/---\s*$/, '').trim();
     }
  }

  // Auto-collapse/open logic
  useEffect(() => {
    // Transition from streaming to not streaming -> Collapse
    if (prevStreamingRef.current && !isStreaming) {
        setIsThinkingOpen(false);
    }
    // Transition from not streaming to streaming (or start) -> Open
    if (!prevStreamingRef.current && isStreaming && thinkingContent) {
        setIsThinkingOpen(true);
    }
    // If currently streaming and content appears for first time
    if (isStreaming && thinkingContent && !prevStreamingRef.current) {
        setIsThinkingOpen(true);
    }

    prevStreamingRef.current = isStreaming;
  }, [isStreaming, thinkingContent ? 'hasContent' : 'noContent']);

  // Initial open check on mount
  useEffect(() => {
      if (isStreaming && thinkingContent && !hasAutoCollapsedRef.current) {
          setIsThinkingOpen(true);
          hasAutoCollapsedRef.current = true;
      }
  }, []); // Run once

  const isUser = role === 'user';

  return (
    <div className={`flex w-full ${isUser ? 'justify-end' : 'justify-start'} mb-6`}>
      <div className={`flex max-w-[85%] ${isUser ? 'flex-row-reverse' : 'flex-row'}`}>
        {/* Avatar */}
        <div className={`flex-shrink-0 h-10 w-10 rounded-full flex items-center justify-center ${
          isUser ? 'bg-blue-600 ml-4' : 'bg-purple-600 mr-4'
        }`}>
          {isUser ? (
            <svg className="w-6 h-6 text-white" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M16 7a4 4 0 11-8 0 4 4 0 018 0zM12 14a7 7 0 00-7 7h14a7 7 0 00-7-7z" />
            </svg>
          ) : (
            <svg className="w-6 h-6 text-white" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M9.75 17L9 20l-1 3m5.25-3l.75 3l1 3M3 13h18M5 17h14a2 2 0 002-2V5a2 2 0 00-2-2H5a2 2 0 00-2 2v10a2 2 0 002 2z" />
            </svg>
          )}
        </div>

        <div className={`flex flex-col min-w-0 ${isUser ? 'items-end' : 'items-start'}`}>
            {/* Thinking Process Accordion (Only for Model) */}
            {!isUser && thinkingContent && (
                <div className="mb-4 w-full max-w-3xl">
                    <button 
                        onClick={() => setIsThinkingOpen(!isThinkingOpen)}
                        className="flex items-center gap-2 text-sm text-gray-400 hover:text-gray-200 transition-colors w-full bg-[#1e1e1e] p-3 rounded-lg border border-gray-700"
                    >
                        {isThinkingOpen ? (
                            <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M19 9l-7 7-7-7" /></svg>
                        ) : (
                            <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M9 5l7 7-7 7" /></svg>
                        )}
                        <span>Thinking Process</span>
                    </button>
                    
                    {isThinkingOpen && (
                        <div className="mt-2 p-4 bg-[#1a1a1a] rounded-lg border-l-2 border-purple-500 text-gray-300 text-sm max-h-[500px] overflow-y-auto animate-fadeIn custom-scrollbar whitespace-pre-wrap break-words">
                             <ReactMarkdown 
                                remarkPlugins={[remarkGfm, remarkMath]}
                                rehypePlugins={[rehypeKatex]}
                                components={{
                                    code({node, inline, className, children, ...props}: any) {
                                        return (
                                            <code className={`${className} bg-gray-800 px-1 py-0.5 rounded text-xs break-all whitespace-pre-wrap`} {...props}>
                                                {children}
                                            </code>
                                        );
                                    },
                                    p: ({node, ...props}) => <p {...props} className="mb-2 last:mb-0" />
                                }}
                            >
                                {thinkingContent}
                            </ReactMarkdown>
                        </div>
                    )}
                </div>
            )}

            {/* Main Message Bubble */}
            {(mainContent || (!thinkingContent && safeText)) && (
                <div className={`rounded-2xl px-6 py-4 shadow-md overflow-hidden ${
                    isUser 
                        ? 'bg-blue-600 text-white rounded-br-none' 
                        : 'bg-[#2d2d2d] text-gray-100 rounded-bl-none border border-gray-700 w-full'
                }`}>
                    <div className="prose prose-invert max-w-none break-words whitespace-pre-wrap">
                        <ReactMarkdown
                            remarkPlugins={[remarkGfm, remarkMath]}
                            rehypePlugins={[rehypeKatex]}
                            components={{
                                code({node, inline, className, children, ...props}: any) {
                                    const match = /language-(\w+)/.exec(className || '');
                                    return !inline && match ? (
                                        <SyntaxHighlighter
                                            style={atomDark}
                                            language={match[1]}
                                            PreTag="div"
                                            {...props}
                                        >
                                            {String(children).replace(/\n$/, '')}
                                        </SyntaxHighlighter>
                                    ) : (
                                        <code className={`${className} bg-black/20 px-1.5 py-0.5 rounded text-sm font-mono`} {...props}>
                                            {children}
                                        </code>
                                    )
                                },
                                a: ({node, ...props}) => <a {...props} className="text-blue-400 hover:underline" target="_blank" rel="noopener noreferrer" />,
                                p: ({node, ...props}) => <p {...props} className="mb-4 last:mb-0 leading-relaxed" />,
                                ul: ({node, ...props}) => <ul {...props} className="list-disc pl-6 mb-4 space-y-1" />,
                                ol: ({node, ...props}) => <ol {...props} className="list-decimal pl-6 mb-4 space-y-1" />,
                                h1: ({node, ...props}) => <h1 {...props} className="text-2xl font-bold mb-4 mt-6 border-b border-gray-700 pb-2" />,
                                h2: ({node, ...props}) => <h2 {...props} className="text-xl font-bold mb-3 mt-5" />,
                                h3: ({node, ...props}) => <h3 {...props} className="text-lg font-bold mb-2 mt-4" />,
                                blockquote: ({node, ...props}) => <blockquote {...props} className="border-l-4 border-gray-500 pl-4 italic my-4 text-gray-400" />,
                                table: ({node, ...props}) => <div className="overflow-x-auto my-4"><table {...props} className="min-w-full divide-y divide-gray-700" /></div>,
                                th: ({node, ...props}) => <th {...props} className="px-3 py-2 bg-gray-800 text-left text-xs font-medium text-gray-300 uppercase tracking-wider" />,
                                td: ({node, ...props}) => <td {...props} className="px-3 py-2 whitespace-nowrap text-sm text-gray-300 border-t border-gray-700" />,
                            }}
                        >
                            {mainContent.trim()}
                        </ReactMarkdown>
                    </div>
                </div>
            )}

            {/* References Section (Only for Model) */}
            {!isUser && referencesContent && (
                <div className="mt-4 w-full">
                    <details className="group">
                        <summary className="flex items-center gap-2 text-xs text-gray-500 hover:text-gray-300 cursor-pointer list-none select-none">
                            <span className="bg-[#2d2d2d] px-2 py-1 rounded border border-gray-700">üìö Reference Sources</span>
                            <svg className="w-3 h-3 transition-transform group-open:rotate-180" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M19 9l-7 7-7-7" /></svg>
                        </summary>
                        <div className="mt-2 p-3 bg-[#1e1e1e] rounded-lg border border-gray-800 text-xs text-gray-400 overflow-hidden">
                             <ReactMarkdown 
                                components={{
                                    a: ({node, ...props}) => <a {...props} className="text-blue-500 hover:underline" target="_blank" rel="noopener noreferrer" />,
                                    ul: ({node, ...props}) => <ul {...props} className="list-none space-y-1" />,
                                    li: ({node, ...props}) => <li {...props} className="truncate" />,
                                }}
                            >
                                {referencesContent}
                            </ReactMarkdown>
                        </div>
                    </details>
                </div>
            )}

            {/* Regenerate Button */}
            {!isUser && isLast && !isStreaming && (
                <div className="mt-2 flex items-center justify-between w-full">
                    <div className="flex items-center gap-2 text-xs text-green-500 font-medium bg-green-500/10 px-2 py-1 rounded border border-green-500/20">
                        <svg className="w-3 h-3" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M5 13l4 4L19 7" />
                        </svg>
                        ÊÄùËÄÉÂÆåÊàê
                    </div>
                    {onRegenerate && (
                        <button 
                            onClick={onRegenerate}
                            className="p-1.5 text-gray-400 hover:text-white hover:bg-[#333537] rounded-full transition-colors"
                            title="Regenerate response"
                        >
                            <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={1.5} d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15" />
                            </svg>
                        </button>
                    )}
                </div>
            )}
        </div>
      </div>
    </div>
  );
};

export default Message;
